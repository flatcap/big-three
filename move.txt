If any move, copy, or destructor is explicitly specified (declared, defined, =default, or =delete) by the user, no move is generated by default.

	template<class T>
	class Handle {
		T* p;
	public:
		Handle(T* pp) : p{pp} {}
		~Handle() { delete p; }		// user-defined destructor: no implicit copy or move 

		Handle(Handle&& h) :p{h.p} { h.p=nullptr; };			// transfer ownership
		Handle& operator=(Handle&& h) { delete p; p=h.p; h.p=nullptr; return *this; }	// transfer ownership

		Handle(const Handle&) = delete;		// no copy
		Handle& operator=(const Handle&) = delete;

		// ...
	};
	
The basic idea for C++11 is to allow a non-static data member to be initialized where it is declared (in its class). A constructor can then use the initializer when run-time initialization is needed. Consider:


	class A {
	public:
		int a = 7;
	};

This is equivalent to:


	class A {
	public:
		int a;
		A() : a(7) {}
	};




	template<class T> class vector {
		// ...
		vector(const vector&);	 		// copy constructor
		vector(vector&&);	 		// move constructor
		vector& operator=(const vector&);	// copy assignment
		vector& operator=(vector&&);		// move assignment
	};	// note: move constructor and move assignment takes non-const &&
		// they can, and usually do, write to their argument



	class Widget {	// Three alternative implementations represented as a union
	private:
		enum class Tag { point, number, text } type;	// discriminant
		union {		// representation
			point p;	  // point has constructor
			int i;
			string s;	 // string has default constructor, copy operations, and destructor
		};
		// ...
		widget& operator=(const widget& w) 	// necessary because of  the string variant
		{
			if (type==Tag::text && w.type==Tag::text) {
				s = w.s;		// usual string assignment
				return *this;
			}

			if (type==Tag::text) s.~string();	// destroy (explicitly!)

			switch (w.type) {
			case Tag::point: p = w.p; break;	// normal copy
			case Tag::number: i = w.i; break;
			case Tag::text: new(&s)(w.s); break;	// placement new
			}
			type = w.type;
			return *this;
		}
	};
	
	

#include <vector>
#include <string>
#include <iostream>
 
struct President
{
    std::string name;
    std::string country;
    int year;
 
    President(std::string p_name, std::string p_country, int p_year)
        : name(std::move(p_name)), country(std::move(p_country)), year(p_year)
    {
        std::cout << "I am being constructed.\n";
    }
    President(President&& other)
        : name(std::move(other.name)), country(std::move(other.country)), year(other.year)
    {
        std::cout << "I am being moved.\n";
    }
    President& operator=(const President& other) = default;
};
 
int main()
{
    std::vector<President> elections;
    std::cout << "emplace_back:\n";
    elections.emplace_back("Nelson Mandela", "South Africa", 1994);
 
    std::vector<President> reElections;
    std::cout << "\npush_back:\n";
    reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));
 
    std::cout << "\nContents:\n";
    for (President const& president: elections) {
        std::cout << president.name << " was elected president of "
                  << president.country << " in " << president.year << ".\n";
    }
    for (President const& president: reElections) {
        std::cout << president.name << " was re-elected president of "
                  << president.country << " in " << president.year << ".\n";
    }
}



	vector<string> vs = { "Hello", ", ", "World!", "\n" };
	for (auto s : vs ) cout << s;
	

